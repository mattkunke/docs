"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9707],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(n),k=i,h=u["".concat(s,".").concat(k)]||u[k]||m[k]||r;return n?a.createElement(h,l(l({ref:t},d),{},{components:n})):a.createElement(h,l({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=k;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},6776:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(3117),i=(n(7294),n(3905));const r={},l="WithdrawalQueueERC721",o={unversionedId:"contracts/withdrawal-queue-erc721",id:"contracts/withdrawal-queue-erc721",title:"WithdrawalQueueERC721",description:"- Source code",source:"@site/docs/contracts/withdrawal-queue-erc721.md",sourceDirName:"contracts",slug:"/contracts/withdrawal-queue-erc721",permalink:"/contracts/withdrawal-queue-erc721",draft:!1,editUrl:"https://github.com/lidofinance/docs/blob/main/docs/contracts/withdrawal-queue-erc721.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"NodeOperatorsRegistry",permalink:"/contracts/node-operators-registry"},next:{title:"WithdrawalVault",permalink:"/contracts/withdrawal-vault"}},s={},p=[{value:"What is WithdrawalQueueERC721?",id:"what-is-withdrawalqueueerc721",level:2},{value:"Request",id:"request",level:2},{value:"Finalization",id:"finalization",level:2},{value:"Claim",id:"claim",level:2},{value:"Standards",id:"standards",level:2},{value:"<code>ERC-721</code>-related Methods",id:"erc-721-related-methods",level:2},{value:"name()",id:"name",level:3},{value:"symbol()",id:"symbol",level:3},{value:"tokenURI()",id:"tokenuri",level:3},{value:"balanceOf()",id:"balanceof",level:3},{value:"ownerOf()",id:"ownerof",level:3},{value:"approve()",id:"approve",level:3},{value:"getApproved()",id:"getapproved",level:3},{value:"setApprovalForAll()",id:"setapprovalforall",level:3},{value:"isApprovedForAll()",id:"isapprovedforall",level:3},{value:"safeTransferFrom()",id:"safetransferfrom",level:3},{value:"transferFrom()",id:"transferfrom",level:3},{value:"getBaseUri()",id:"getbaseuri",level:3},{value:"getNFTDescriptorAddress()",id:"getnftdescriptoraddress",level:3},{value:"<code>ERC-165</code>-related Methods",id:"erc-165-related-methods",level:2},{value:"supportsInterface()",id:"supportsinterface",level:3},{value:"Queue-related Methods",id:"queue-related-methods",level:2},{value:"requestWithdrawals()",id:"requestwithdrawals",level:3},{value:"requestWithdrawalsWstETH()",id:"requestwithdrawalswsteth",level:3},{value:"requestWithdrawalsWithPermit()",id:"requestwithdrawalswithpermit",level:3},{value:"requestWithdrawalsWstETHWithPermit()",id:"requestwithdrawalswstethwithpermit",level:3},{value:"getWithdrawalRequests()",id:"getwithdrawalrequests",level:3},{value:"getWithdrawalStatus()",id:"getwithdrawalstatus",level:3},{value:"getClaimableEther()",id:"getclaimableether",level:3},{value:"claimWithdrawalsTo()",id:"claimwithdrawalsto",level:3},{value:"claimWithdrawals()",id:"claimwithdrawals",level:3},{value:"claimWithdrawal()",id:"claimwithdrawal",level:3},{value:"findCheckpointHints()",id:"findcheckpointhints",level:3},{value:"isBunkerModeActive()",id:"isbunkermodeactive",level:3},{value:"bunkerModeSinceTimestamp()",id:"bunkermodesincetimestamp",level:3},{value:"getLastRequestId()",id:"getlastrequestid",level:3},{value:"getLastFinalizedRequestId()",id:"getlastfinalizedrequestid",level:3},{value:"getLockedEtherAmount()",id:"getlockedetheramount",level:3},{value:"getLastCheckpointIndex()",id:"getlastcheckpointindex",level:3},{value:"unfinalizedRequestNumber()",id:"unfinalizedrequestnumber",level:3},{value:"unfinalizedStETH()",id:"unfinalizedsteth",level:3},{value:"calculateFinalizationBatches()",id:"calculatefinalizationbatches",level:3},{value:"prefinalize()",id:"prefinalize",level:3},{value:"Protected methods",id:"protected-methods",level:2},{value:"Roles",id:"roles",level:3},{value:"finalize()",id:"finalize",level:3},{value:"pauseFor()",id:"pausefor",level:3},{value:"pauseUntil()",id:"pauseuntil",level:3},{value:"resume()",id:"resume",level:3},{value:"onOracleReport()",id:"onoraclereport",level:3},{value:"setBaseUri()",id:"setbaseuri",level:3},{value:"setNFTDescriptorAddress()",id:"setnftdescriptoraddress",level:3}],d={toc:p},u="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"withdrawalqueueerc721"},"WithdrawalQueueERC721"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/lidofinance/lido-dao/blob/master/contracts/0.8.9/WithdrawalQueueERC721.sol"},"Source code")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://etherscan.io/address/0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1"},"Deployed contract"))),(0,i.kt)("p",null,"A FIFO queue for ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH")," withdrawal requests and an ",(0,i.kt)("inlineCode",{parentName:"p"},"unstETH")," NFT implementation representing the position in the queue."),(0,i.kt)("p",null,"Access to lever methods is restricted using the functionality of the\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lidofinance/lido-dao/blob/master/contracts/0.8.9/utils/access/AccessControlEnumerable.sol"},"AccessControlEnumerable"),"\ncontract and a bunch of ",(0,i.kt)("a",{parentName:"p",href:"#roles"},"granular roles"),"."),(0,i.kt)("h2",{id:"what-is-withdrawalqueueerc721"},"What is WithdrawalQueueERC721?"),(0,i.kt)("p",null,"This contract is a main entry point to exchange ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH")," for underlying ether directly via Lido protocol.\nIt is responsible for:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"managing a queue of withdrawal requests"),(0,i.kt)("li",{parentName:"ul"},"committing withdrawal request finalization as a part of the ",(0,i.kt)("a",{parentName:"li",href:"/contracts/accounting-oracle"},"AccountingOracle")," report"),(0,i.kt)("li",{parentName:"ul"},"storing ",(0,i.kt)("inlineCode",{parentName:"li"},"stETH")," before and ether after the finalization"),(0,i.kt)("li",{parentName:"ul"},"transfer reserved ether to the user upon the claim")),(0,i.kt)("p",null,"Also, the contract is ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-721"},"ERC-721")," ",(0,i.kt)("inlineCode",{parentName:"p"},"unstETH")," NFT with\nmetadata extension representing the right to claim underlying ether once the request is\nfinalized. This NFT is minted upon request and burned on the claim. ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-4906"},"ERC-4906"),"\nis used to update the metadata as soon as the finalization status of the request is changed."),(0,i.kt)("h2",{id:"request"},"Request"),(0,i.kt)("p",null,"To request a withdrawal, one needs to approve the amount of ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"wstETH")," to this contract or sign the\n",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-2612"},"ERC-2612 Permit"),", and then call the appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"requestWithdrawals*")," method."),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"minimal")," amount for a request is ",(0,i.kt)("inlineCode",{parentName:"p"},"100 wei"),", and the ",(0,i.kt)("strong",{parentName:"p"},"maximum")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"1000 eth"),". More significant amounts should\nbe split into several requests, which allows us to avoid clogging the queue with an extra large request."),(0,i.kt)("p",null,"During this call, the request is placed in the queue, and the related ",(0,i.kt)("inlineCode",{parentName:"p"},"unstETH")," NFT is minted. The following structure\nrepresents the request:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"struct WithdrawalRequestStatus {\n    uint256 amountOfStETH;\n    uint256 amountOfShares;\n    address owner;\n    uint256 timestamp;\n    bool isFinalized;\n    bool isClaimed;\n}\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"amountOfStETH"))," \u2014 the number of ",(0,i.kt)("inlineCode",{parentName:"li"},"stETH")," tokens transferred to the contract upon request"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"amountOfShares"))," \u2014 the number of underlying shares corresponding to transferred ",(0,i.kt)("inlineCode",{parentName:"li"},"stETH")," tokens.\nSee ",(0,i.kt)("a",{parentName:"li",href:"/contracts/lido#rebase"},"Lido rebasing chapter")," to learn about the shares mechanic"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"owner"))," \u2014 the owner's address for this request. The owner is also a holder of the ",(0,i.kt)("inlineCode",{parentName:"li"},"unstETH")," NFT\nand can transfer the ownership and claim the underlying ether once finalized"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"timestamp"))," \u2014 the creation time of the request"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"isFinalized"))," \u2014 finalization status of the request; finalized requests are available to claim"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"isClaimed"))," \u2014 the claim status of the request. Once claimed, NFT is burned, and\nthe request is not available to claim again")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The amount of ether that will be withdrawn is limited to the number of ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH")," tokens transferred to this contract\nat the moment of request. So, the user will not receive the rewards for the period of time while their tokens stay in the queue.")),(0,i.kt)("h2",{id:"finalization"},"Finalization"),(0,i.kt)("p",null,"After filing a withdrawal request, one can only claim it once finalization occurs.\n",(0,i.kt)("a",{parentName:"p",href:"/contracts/accounting-oracle"},"Accounting Oracle")," report finalizes a batch of withdrawal requests,\nchoosing the ",(0,i.kt)("inlineCode",{parentName:"p"},"_maxShareRate")," and the size of the batch taking in account following factors:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If there is enough ether to fulfill the request. Ether can be obtained from the Lido buffer, which is filled\nfrom the new users' stake, Beacon chain partial and full withdrawals, protocol tips, and MEV rewards.\nWithdrawals are prioritized over deposits, so ether can't be deposited to the Beacon chain if some withdrawal requests\ncan be fulfilled."),(0,i.kt)("li",{parentName:"ul"},"if enough time has passed since the withdrawal request was placed in the queue (timelock)"),(0,i.kt)("li",{parentName:"ul"},"If there was some massive loss for the protocol on the Beacon Chain side since the withdrawal request was filed.\nIt can lead to finalization by the rate lower than 1:1 if the loss will be high enough to be not covered\nwith daily rewards (never happened before)")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"To put it simply, token holders don't receive rewards but still take risks during withdrawal. Rewards, acquired\nsince the stETH was locked in the WithdrawalQueue, are burned upon the finalization, effectively distributing them\namong the other token holders.")),(0,i.kt)("p",null,"So, the finalization sets the final value of the request, locks ether on the balance of this contract,\nand burns the underlying ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH")," and the queue may look like this in arbitrary moment:"),(0,i.kt)("mermaid",{value:"graph LR\n    subgraph queue\n    direction LR\n    B---D\n    subgraph unfinalized;\n        A[1 stETH]---B[1.1 stETH]\n    end\n    subgraph finalized;\n        D(0.3 ETH)---E(1000 ETH)\n    end\n    end\n\n    classDef gr fill:#d0f0c0,stroke:#333,stroke-width:3px;;\n    classDef r fill:#fa8072,stroke:#333,stroke-width:3px;;\n\n    class A,B r;\n    class D,E gr;\n"}),(0,i.kt)("h2",{id:"claim"},"Claim"),(0,i.kt)("p",null,"When the request is finalized, it can be claimed by the current owner, transferring the reserved amount of ether to\nthe recipient's address and burning the withdrawal NFT."),(0,i.kt)("p",null,"To see if the request is claimable, one can get its status using ",(0,i.kt)("inlineCode",{parentName:"p"},"getWithdrawalStatus()")," or subscribe to\nthe event ",(0,i.kt)("inlineCode",{parentName:"p"},"WithdrawalsFinalized(uint256 from, uint256 to, ...)"),", which is emitted once the batch of requests\nwith ids in the range ",(0,i.kt)("inlineCode",{parentName:"p"},"(from, to]")," is finalized."),(0,i.kt)("h2",{id:"standards"},"Standards"),(0,i.kt)("p",null,"Contract implements the following Ethereum standards:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-721"},"ERC-721: Non-Fungible Token Standard")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-165"},"ERC-165: Standard Interface Detection")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-4906"},"ERC-4906: EIP-721 Metadata Update Extension"))),(0,i.kt)("h2",{id:"erc-721-related-methods"},(0,i.kt)("inlineCode",{parentName:"h2"},"ERC-721"),"-related Methods"),(0,i.kt)("h3",{id:"name"},"name()"),(0,i.kt)("p",null,"Returns the token collection name."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function name() view returns (string memory)\n")),(0,i.kt)("h3",{id:"symbol"},"symbol()"),(0,i.kt)("p",null,"Returns the token collection symbol."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function symbol() view returns (string memory)\n")),(0,i.kt)("h3",{id:"tokenuri"},"tokenURI()"),(0,i.kt)("p",null,"Returns the Uniform Resource Identifier (URI) for the ",(0,i.kt)("inlineCode",{parentName:"p"},"_requestId")," token. Returns an empty string if no base URI\nand no ",(0,i.kt)("inlineCode",{parentName:"p"},"NFTDescriptor")," address are set."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function tokenURI(uint256 _requestId) view returns (string memory)\n")),(0,i.kt)("h3",{id:"balanceof"},"balanceOf()"),(0,i.kt)("p",null,"Returns the number of tokens in the ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner"),"'s account."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function balanceOf(address _owner) view returns (uint256 balance)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Reverts if ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner")," is zero address")),(0,i.kt)("h3",{id:"ownerof"},"ownerOf()"),(0,i.kt)("p",null,"Returns the owner of the ",(0,i.kt)("inlineCode",{parentName:"p"},"_requestId")," token."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function ownerOf(uint256 _requestId) view returns (address owner)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre"},"- `_requestId` request must exist.\n- `_requestId` request must not be claimed.\n"))),(0,i.kt)("h3",{id:"approve"},"approve()"),(0,i.kt)("p",null,"Gives permission to ",(0,i.kt)("inlineCode",{parentName:"p"},"_to")," to transfer the ",(0,i.kt)("inlineCode",{parentName:"p"},"_requestId")," token to another account. The approval is cleared when\nthe token is transferred."),(0,i.kt)("p",null,"Emits an ",(0,i.kt)("inlineCode",{parentName:"p"},"Approval")," event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function approve(address _to, uint256 _requestId)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre"},"- The caller must own the token or be an approved operator.\n- `_requestId` must exist.\n- `_to` must not be the owner\n"))),(0,i.kt)("h3",{id:"getapproved"},"getApproved()"),(0,i.kt)("p",null,"Returns the account approved for the ",(0,i.kt)("inlineCode",{parentName:"p"},"_requestId")," token."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function getApproved(uint256 _requestId) view returns (address)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Reverts if no ",(0,i.kt)("inlineCode",{parentName:"p"},"_requestId")," exists")),(0,i.kt)("h3",{id:"setapprovalforall"},"setApprovalForAll()"),(0,i.kt)("p",null,"Approve or remove ",(0,i.kt)("inlineCode",{parentName:"p"},"_operator")," as an operator for the caller. Operators can call ",(0,i.kt)("inlineCode",{parentName:"p"},"transferFrom")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"safeTransferFrom"),"\nfor any token owned by the caller."),(0,i.kt)("p",null,"Emits an ",(0,i.kt)("inlineCode",{parentName:"p"},"ApprovalForAll")," event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function setApprovalForAll(address _operator, bool _approved)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Reverts if ",(0,i.kt)("inlineCode",{parentName:"p"},"msg.sender")," is equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"_operator"))),(0,i.kt)("h3",{id:"isapprovedforall"},"isApprovedForAll()"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the ",(0,i.kt)("inlineCode",{parentName:"p"},"_operator")," is allowed to manage all of the assets of the ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function isApprovedForAll(address _owner, address _operator) view returns (bool)\n")),(0,i.kt)("h3",{id:"safetransferfrom"},"safeTransferFrom()"),(0,i.kt)("p",null,"Safely transfers the ",(0,i.kt)("inlineCode",{parentName:"p"},"_requestId")," token from ",(0,i.kt)("inlineCode",{parentName:"p"},"_from")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"_to"),", checking first that contract recipients are aware of\nthe ERC721 protocol to prevent tokens from being forever locked.\nIf a version with ",(0,i.kt)("inlineCode",{parentName:"p"},"_data")," parameter is used, it passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"IERC721Receiver.onERC721Received()")," of the target\nsmart contract as an argument."),(0,i.kt)("p",null,"Emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function safeTransferFrom(address _from, address _to, uint256 _requestId)\nfunction safeTransferFrom(address _from, address _to, uint256 _requestId, bytes memory _data)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_from")," cannot be the zero address."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_to")," cannot be the zero address."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_requestId")," token must exist and be owned by ",(0,i.kt)("inlineCode",{parentName:"li"},"_from"),"."),(0,i.kt)("li",{parentName:"ul"},"If the caller is not ",(0,i.kt)("inlineCode",{parentName:"li"},"_from"),", it must have been allowed to move this token by either ",(0,i.kt)("inlineCode",{parentName:"li"},"approve()")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"setApprovalForAll()"),"."),(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"_to")," refers to a smart contract, it must implement ",(0,i.kt)("inlineCode",{parentName:"li"},"IERC721Receiver")," interface"))),(0,i.kt)("h3",{id:"transferfrom"},"transferFrom()"),(0,i.kt)("p",null,"Transfers the ",(0,i.kt)("inlineCode",{parentName:"p"},"_requestId")," token from ",(0,i.kt)("inlineCode",{parentName:"p"},"_from")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"_to"),"."),(0,i.kt)("p",null,"Emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"WARNING"),": Usage of this method is discouraged, use ",(0,i.kt)("inlineCode",{parentName:"p"},"safeTransferFrom()")," whenever possible."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function transferFrom(address _from, address _to, uint256 _requestId)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_from")," cannot be the zero address."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_to")," cannot be the zero address."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_requestId")," token must be owned by ",(0,i.kt)("inlineCode",{parentName:"li"},"_from"),"."),(0,i.kt)("li",{parentName:"ul"},"If the caller is not ",(0,i.kt)("inlineCode",{parentName:"li"},"_from"),", it must be approved to move this token by either ",(0,i.kt)("inlineCode",{parentName:"li"},"approve()")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"setApprovalForAll()"),"."))),(0,i.kt)("h3",{id:"getbaseuri"},"getBaseUri()"),(0,i.kt)("p",null,"Returns the base URI for computing token URI. If set, the resulting URI for each token will be the concatenation\nof the base URI and the ",(0,i.kt)("inlineCode",{parentName:"p"},"_requestId"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function getBaseURI() view returns (string memory)\n")),(0,i.kt)("h3",{id:"getnftdescriptoraddress"},"getNFTDescriptorAddress()"),(0,i.kt)("p",null,"Returns the address of the ",(0,i.kt)("inlineCode",{parentName:"p"},"NFTDescriptor")," contract responsible for the token URI generation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function getNFTDescriptorAddress() view returns (address)\n")),(0,i.kt)("h2",{id:"erc-165-related-methods"},(0,i.kt)("inlineCode",{parentName:"h2"},"ERC-165"),"-related Methods"),(0,i.kt)("h3",{id:"supportsinterface"},"supportsInterface()"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if this contract implements the interface defined by ",(0,i.kt)("inlineCode",{parentName:"p"},"interfaceId"),". See\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified"},"ERC-165")," to learn more about\nhow these ids are created."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function supportsInterface(bytes4 interfaceId) view returns (bool)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This contract returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"IERC721"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"IERC721Metadata"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"IERC4906"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"IAccessControlEnumerable"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"IAccessControl")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"IERC165")," itself.")),(0,i.kt)("h2",{id:"queue-related-methods"},"Queue-related Methods"),(0,i.kt)("h3",{id:"requestwithdrawals"},"requestWithdrawals()"),(0,i.kt)("p",null,"Batch request the ",(0,i.kt)("inlineCode",{parentName:"p"},"_amounts")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH")," for withdrawal to the ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner")," address. For each request, the respective\namount of ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH")," is transferred to this contract address, and an ",(0,i.kt)("inlineCode",{parentName:"p"},"unstETH")," NFT is minted to the ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner")," address."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function requestWithdrawals(uint256[] _amounts, address _owner) returns (uint256[] requestIds)\n")),(0,i.kt)("p",null,"Returns the array of ids for each created request. Emits ",(0,i.kt)("inlineCode",{parentName:"p"},"WithdrawalRequested")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Transfer")," events."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"withdrawals must not be paused"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"stETH")," balance of ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must be greater than the sum of all ",(0,i.kt)("inlineCode",{parentName:"li"},"_amounts")),(0,i.kt)("li",{parentName:"ul"},"there must be approval from the ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," to this contract address for the overall amount of ",(0,i.kt)("inlineCode",{parentName:"li"},"stETH")," token transfer"),(0,i.kt)("li",{parentName:"ul"},"each amount in ",(0,i.kt)("inlineCode",{parentName:"li"},"_amounts")," must be greater than ",(0,i.kt)("inlineCode",{parentName:"li"},"MIN_STETH_WITHDRAWAL_AMOUNT")," and lower than ",(0,i.kt)("inlineCode",{parentName:"li"},"MAX_STETH_WITHDRAWAL_AMOUNT")))),(0,i.kt)("h3",{id:"requestwithdrawalswsteth"},"requestWithdrawalsWstETH()"),(0,i.kt)("p",null,"Batch request the ",(0,i.kt)("inlineCode",{parentName:"p"},"_amounts")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"wstETH")," for withdrawal to the ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner")," address. For each request,\nthe respective amount of ",(0,i.kt)("inlineCode",{parentName:"p"},"wstETH")," is transferred to this contract address, unwrapped to ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH"),",\nand an ",(0,i.kt)("inlineCode",{parentName:"p"},"unstETH")," NFT is minted to the ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner")," address."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function requestWithdrawalsWstETH(uint256[] _amounts, address _owner) returns (uint256[] requestIds)\n")),(0,i.kt)("p",null,"Returns the array of ids for each created request. Emits ",(0,i.kt)("inlineCode",{parentName:"p"},"WithdrawalRequested")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Transfer")," events."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"withdrawals must not be paused"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wstETH")," balance of ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must be greater than the sum of all ",(0,i.kt)("inlineCode",{parentName:"li"},"_amounts")),(0,i.kt)("li",{parentName:"ul"},"there must be approval from the ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," to this contract address for the overall amount of ",(0,i.kt)("inlineCode",{parentName:"li"},"wstETH")," token transfer"),(0,i.kt)("li",{parentName:"ul"},"each amount in ",(0,i.kt)("inlineCode",{parentName:"li"},"_amounts")," must have ",(0,i.kt)("inlineCode",{parentName:"li"},"getPooledEthByShares(amount)")," being greater than  ",(0,i.kt)("inlineCode",{parentName:"li"},"MIN_STETH_WITHDRAWAL_AMOUNT"),"\nand lower than ",(0,i.kt)("inlineCode",{parentName:"li"},"MAX_STETH_WITHDRAWAL_AMOUNT")))),(0,i.kt)("h3",{id:"requestwithdrawalswithpermit"},"requestWithdrawalsWithPermit()"),(0,i.kt)("p",null,"Batch request the ",(0,i.kt)("inlineCode",{parentName:"p"},"_amounts")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH")," for withdrawal to the ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner")," address. For each request,\nthe respective amount of ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH")," is transferred to this contract address,\nand an ",(0,i.kt)("inlineCode",{parentName:"p"},"unstETH")," NFT is minted to the ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner")," address. ",(0,i.kt)("inlineCode",{parentName:"p"},"ERC-2612")," permit is used to approve the token transfer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function requestWithdrawalsWithPermit(\n    uint256[] _amounts,\n    address _owner,\n    PermitInput _permit\n) returns (uint256[] requestIds)\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"_permit")," is ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-2612"},"ERC-2612")," signed permit structure defined as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"struct PermitInput {\n    uint256 value;\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n")),(0,i.kt)("p",null,"Returns the array of ids for each created request. Emits ",(0,i.kt)("inlineCode",{parentName:"p"},"WithdrawalRequested")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Transfer")," events."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"withdrawals must not be paused"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"stETH")," balance of ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must be greater than the sum of all ",(0,i.kt)("inlineCode",{parentName:"li"},"_amounts")),(0,i.kt)("li",{parentName:"ul"},"permit must have a valid signature, ",(0,i.kt)("inlineCode",{parentName:"li"},"value")," greater than the sum of all ",(0,i.kt)("inlineCode",{parentName:"li"},"_amounts"),", and the ",(0,i.kt)("inlineCode",{parentName:"li"},"deadline")," not expired"),(0,i.kt)("li",{parentName:"ul"},"each amount in ",(0,i.kt)("inlineCode",{parentName:"li"},"_amounts")," must be greater than ",(0,i.kt)("inlineCode",{parentName:"li"},"MIN_STETH_WITHDRAWAL_AMOUNT")," and lower than ",(0,i.kt)("inlineCode",{parentName:"li"},"MAX_STETH_WITHDRAWAL_AMOUNT")))),(0,i.kt)("h3",{id:"requestwithdrawalswstethwithpermit"},"requestWithdrawalsWstETHWithPermit()"),(0,i.kt)("p",null,"Batch request the ",(0,i.kt)("inlineCode",{parentName:"p"},"_amounts")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"wstETH")," for withdrawal to the ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner")," address. For each request,\nthe respective amount of ",(0,i.kt)("inlineCode",{parentName:"p"},"wstETH")," is transferred to this contract address, unwrapped to ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH"),",\nand an ",(0,i.kt)("inlineCode",{parentName:"p"},"unstETH")," NFT is minted to the ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner")," address.",(0,i.kt)("inlineCode",{parentName:"p"},"ERC-2612")," permit is used to approve the token transfer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function requestWithdrawalsWstETHWithPermit(\n  uint256[] _amounts,\n  address _owner,\n  PermitInput _permit\n) returns (uint256[] requestIds)\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"_permit")," is ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-2612"},"ERC-2612")," signed permit structure defined as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"struct PermitInput {\n    uint256 value;\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n")),(0,i.kt)("p",null,"Returns the array of ids for each created request. Emits ",(0,i.kt)("inlineCode",{parentName:"p"},"WithdrawalRequested")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Transfer")," events."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"withdrawals must not be paused"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wstETH")," balance of ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must be greater than the sum of all ",(0,i.kt)("inlineCode",{parentName:"li"},"_amounts")),(0,i.kt)("li",{parentName:"ul"},"permit must have a valid signature, ",(0,i.kt)("inlineCode",{parentName:"li"},"value")," greater than the sum of all ",(0,i.kt)("inlineCode",{parentName:"li"},"_amounts"),", and the ",(0,i.kt)("inlineCode",{parentName:"li"},"deadline")," not expired"),(0,i.kt)("li",{parentName:"ul"},"each amount in ",(0,i.kt)("inlineCode",{parentName:"li"},"_amounts")," must have ",(0,i.kt)("inlineCode",{parentName:"li"},"getPooledEthByShares(amount)")," being greater than  ",(0,i.kt)("inlineCode",{parentName:"li"},"MIN_STETH_WITHDRAWAL_AMOUNT"),"\nand lower than ",(0,i.kt)("inlineCode",{parentName:"li"},"MAX_STETH_WITHDRAWAL_AMOUNT")))),(0,i.kt)("h3",{id:"getwithdrawalrequests"},"getWithdrawalRequests()"),(0,i.kt)("p",null,"Returns all withdrawal requests that belong to the ",(0,i.kt)("inlineCode",{parentName:"p"},"_owner")," address."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function getWithdrawalRequests(address _owner) view returns (uint256[] requestsIds)\n")),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"This operation will copy the entire storage to memory, which can be quite expensive. This method is designed to mostly\nbe used by view accessors that are queried without gas fees. Developers should keep in mind that this function has an\nunbounded cost, and using it as part of a state-changing function may render the function uncallable if the set grows\nto a point where copying to memory consumes too much gas to fit in a block.")),(0,i.kt)("h3",{id:"getwithdrawalstatus"},"getWithdrawalStatus()"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"statuses")," for requests with ids in ",(0,i.kt)("inlineCode",{parentName:"p"},"_requestIds"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function getWithdrawalStatus(uint256[] _requestIds)\n    view\n    returns (WithdrawalRequestStatus[] statuses)\n")),(0,i.kt)("p",null,"Returns an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"WithdrawalRequestStatus")," structures, defined as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"struct WithdrawalRequestStatus {\n    uint256 amountOfStETH;\n    uint256 amountOfShares;\n    address owner;\n    uint256 timestamp;\n    bool isFinalized;\n    bool isClaimed;\n}\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"amountOfStETH"))," \u2014 the number of ",(0,i.kt)("inlineCode",{parentName:"li"},"stETH")," tokens transferred to the contract upon request"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"amountOfShares"))," \u2014 the number of underlying shares corresponding to transferred ",(0,i.kt)("inlineCode",{parentName:"li"},"stETH")," tokens.\nSee ",(0,i.kt)("a",{parentName:"li",href:"/contracts/lido#rebase"},"Lido rebasing chapter")," to learn about the shares mechanic"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"owner"))," \u2014 the owner's address for this request. The owner is also a holder of the ",(0,i.kt)("inlineCode",{parentName:"li"},"unstETH")," NFT\nand can transfer the ownership and claim the underlying ether once finalized"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"timestamp"))," \u2014 the creation time of the request"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"isFinalized"))," \u2014 finalization status of the request; finalized requests are available to claim"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"isClaimed"))," \u2014 the claim status of the request. Once claimed, NFT is burned, and the request\nis not available to claim again")),(0,i.kt)("h3",{id:"getclaimableether"},"getClaimableEther()"),(0,i.kt)("p",null,"Returns amounts of ether available for claiming for each provided request id."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function getClaimableEther(uint256[] _requestIds, uint256[] _hints)\n    view\n    returns (uint256[] claimableEthValues)\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_requestIds"))," \u2014 the array of request id to check the claimable ether for"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_hints"))," \u2014 checkpoint hint for each request id. Can be obtained by calling ",(0,i.kt)("a",{parentName:"li",href:"#findcheckpointhints"},(0,i.kt)("inlineCode",{parentName:"a"},"findCheckpointHints()")))),(0,i.kt)("p",null,"Returns the array of ether amounts available for claiming for each request id. The amount is equal to 0 if the request is not finalized or already claimed."),(0,i.kt)("h3",{id:"claimwithdrawalsto"},"claimWithdrawalsTo()"),(0,i.kt)("p",null,"Claim a batch of withdrawal requests if they are finalized, sending ether to ",(0,i.kt)("inlineCode",{parentName:"p"},"_recipient")," address."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function claimWithdrawalsTo(uint256[] _requestIds, uint256[] _hints, address _recipient)\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_requestIds"))," \u2014 the array of request id to check the claimable ether for"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_hints"))," \u2014 checkpoint hint for each request id. Can be obtained by calling ",(0,i.kt)("a",{parentName:"li",href:"#findcheckpointhints"},(0,i.kt)("inlineCode",{parentName:"a"},"findCheckpointHints()"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_recipient"))," \u2014 the address of the recipient for claimed ether")),(0,i.kt)("p",null,"Emits a batch of ",(0,i.kt)("inlineCode",{parentName:"p"},"Transfer")," to zero address and ",(0,i.kt)("inlineCode",{parentName:"p"},"WithdrawalClaimed")," events."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"all ",(0,i.kt)("inlineCode",{parentName:"li"},"_requestIds")," must exist, be finalized and not claimed"),(0,i.kt)("li",{parentName:"ul"},"all ",(0,i.kt)("inlineCode",{parentName:"li"},"_hints")," must be valid for respective requests"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must be the owner of all the requests"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_recipient")," must not be zero"))),(0,i.kt)("h3",{id:"claimwithdrawals"},"claimWithdrawals()"),(0,i.kt)("p",null,"Claim a batch of withdrawal requests if they are finalized, sending ether to ",(0,i.kt)("inlineCode",{parentName:"p"},"msg.sender")," address."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function claimWithdrawals(uint256[] _requestIds, uint256[] _hints)\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_requestIds"))," \u2014 the array of request id to check the claimable ether for"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_hints"))," \u2014 checkpoint hint for each request id. Can be obtained by calling ",(0,i.kt)("a",{parentName:"li",href:"#findcheckpointhints"},(0,i.kt)("inlineCode",{parentName:"a"},"findCheckpointHints()")))),(0,i.kt)("p",null,"Emits a batch of ",(0,i.kt)("inlineCode",{parentName:"p"},"Transfer")," to zero address and ",(0,i.kt)("inlineCode",{parentName:"p"},"WithdrawalClaimed")," events."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"all ",(0,i.kt)("inlineCode",{parentName:"li"},"_requestIds")," must exist, be finalized and not claimed"),(0,i.kt)("li",{parentName:"ul"},"all ",(0,i.kt)("inlineCode",{parentName:"li"},"_hints")," must be valid for respective requests"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must be the owner of all the requests"))),(0,i.kt)("h3",{id:"claimwithdrawal"},"claimWithdrawal()"),(0,i.kt)("p",null,"Claims the ",(0,i.kt)("inlineCode",{parentName:"p"},"_requestId")," withdrawal request, sending ether to ",(0,i.kt)("inlineCode",{parentName:"p"},"msg.sender")," address."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function claimWithdrawal(uint256 _requestId)\n")),(0,i.kt)("p",null,"Emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"Transfer")," to zero address and ",(0,i.kt)("inlineCode",{parentName:"p"},"WithdrawalClaimed")," event."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must be the owner of the ",(0,i.kt)("inlineCode",{parentName:"li"},"_requestId")," request"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_requestId")," request must exist, be finalized and not claimed"))),(0,i.kt)("h3",{id:"findcheckpointhints"},"findCheckpointHints()"),(0,i.kt)("p",null,"Returns an array of hints for the given ",(0,i.kt)("inlineCode",{parentName:"p"},"_requestIds")," searching among the checkpoints with indices\nin the range  ",(0,i.kt)("inlineCode",{parentName:"p"},"[_firstIndex, _lastIndex]"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function findCheckpointHints(uint256[] _requestIds, uint256 _firstIndex, uint256 _lastIndex)\n    view\n    returns (uint256[] hintIds)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Array of request ids must be sorted"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_firstIndex")," must be greater than 0, because checkpoint list is 1-based array"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_lastIndex")," must be less than or equal to ",(0,i.kt)("a",{parentName:"li",href:"#getlastcheckpointindex"},(0,i.kt)("inlineCode",{parentName:"a"},"getLastCheckpointIndex()"))))),(0,i.kt)("h3",{id:"isbunkermodeactive"},"isBunkerModeActive()"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if bunker mode is active."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function isBunkerModeActive() view returns (bool)\n")),(0,i.kt)("h3",{id:"bunkermodesincetimestamp"},"bunkerModeSinceTimestamp()"),(0,i.kt)("p",null,"Returns the timestamp of the last bunker mode activation, if it's active now and\n",(0,i.kt)("inlineCode",{parentName:"p"},"BUNKER_MODE_DISABLED_TIMESTAMP")," if bunker mode is disabled (i.e., protocol in turbo mode)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function bunkerModeSinceTimestamp() view returns (uint256)\n")),(0,i.kt)("h3",{id:"getlastrequestid"},"getLastRequestId()"),(0,i.kt)("p",null,"Returns the id of the last request in the queue."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function getLastRequestId() view returns (uint256)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requests are indexed from ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", so it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," if there are no requests in the queue.")),(0,i.kt)("h3",{id:"getlastfinalizedrequestid"},"getLastFinalizedRequestId()"),(0,i.kt)("p",null,"Returns the id of the last finalized request in the queue."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function getLastFinalizedRequestId() view returns (uint256)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requests are indexed from ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", so it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," if there are no finalized requests in the queue.")),(0,i.kt)("h3",{id:"getlockedetheramount"},"getLockedEtherAmount()"),(0,i.kt)("p",null,"Returns the amount of ether on the balance locked for withdrawal and available to claim."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function getLockedEtherAmount() view returns (uint256)\n")),(0,i.kt)("h3",{id:"getlastcheckpointindex"},"getLastCheckpointIndex()"),(0,i.kt)("p",null,"Returns the length of the checkpoint array. Last possible value for the hint."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function getLastCheckpointIndex() view returns (uint256)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Checkpoints are indexed from ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", so it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," if there are no checkpoints yet.")),(0,i.kt)("h3",{id:"unfinalizedrequestnumber"},"unfinalizedRequestNumber()"),(0,i.kt)("p",null,"Returns the number of unfinalized requests in the queue."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function unfinalizedRequestNumber() view returns (uint256)\n")),(0,i.kt)("h3",{id:"unfinalizedsteth"},"unfinalizedStETH()"),(0,i.kt)("p",null,"Returns the amount of ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH")," in the queue yet to be finalized."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function unfinalizedStETH() view returns (uint256)\n")),(0,i.kt)("h3",{id:"calculatefinalizationbatches"},"calculateFinalizationBatches()"),(0,i.kt)("p",null,"View for offchain use by the oracle daemon that calculates how many requests can be finalized within the given budget,\ntime period, and share rate limits. Returned requests are split into batches. All requests belonging to one batch must\nhave their share rate above or below (or equal) to the ",(0,i.kt)("inlineCode",{parentName:"p"},"_maxShareRate"),". Below you can see an example of how 14 requests\nwith different share rates will be split into five batches by this method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-txt"}," ^ share rate\n |\n |         \u2022 \u2022\n |       \u2022    \u2022   \u2022 \u2022 \u2022\n |----------------------\u2022------   _maxShareRate\n |   \u2022          \u2022        \u2022 \u2022 \u2022\n | \u2022\n +-------------------------------\x3e requestId\n  | 1 |    2   |3|  4  |   5   |    batch number\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function calculateFinalizationBatches(\n    uint256 _maxShareRate,\n    uint256 _maxTimestamp,\n    uint256 _maxRequestsPerCall,\n    BatchesCalculationState _state\n) external view returns (BatchesCalculationState)\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"_maxShareRate"))," \u2014 the max share rate (ETH per share) that will be used for the finalization (1e27 precision)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"_maxTimestamp"))," \u2014 the max timestamp of the request that can be finalized")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"_maxRequestsPerCall"))," \u2014 the max request number that can be processed per iteration")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"_state"))," \u2014 the current state of the calculation, represented with a ",(0,i.kt)("inlineCode",{parentName:"p"},"BatchesCalculationState")," structure:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"struct BatchesCalculationState {\n    uint256 remainingEthBudget;\n    bool finished;\n    uint256[MAX_BATCHES_LENGTH] batches;\n    uint256 batchesLength;\n}\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"remainingEthBudget"))," \u2014 the currently remaining amount of ether. It must be set into the whole budget of\nthe finalization at the first call"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"finished"))," \u2014 the flag that is set to ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," if all requests are iterated on"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"batches"))," \u2014 the resulting array of batches, each represented by the id of the last request in the batch"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"batchesLength"))," \u2014 the length of the filled part of the ",(0,i.kt)("inlineCode",{parentName:"li"},"batches")," array")))),(0,i.kt)("p",null,"Returns the current state of the finalization batch calculation."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This method is designed for iterative usage under gas limits. So, in the case of the number of withdrawals are\ntoo large to iterate over in one call, one can use this method repeatedly, passing the return value as an argument\nfor the next call as long as it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"finished")," equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"false"))),(0,i.kt)("h3",{id:"prefinalize"},"prefinalize()"),(0,i.kt)("p",null,"Checks finalization batches and calculates the required amount of ether to lock and the number of shares to burn."),(0,i.kt)("p",null,"Designed to use during the oracle report to find the amount of ether to send along the ",(0,i.kt)("inlineCode",{parentName:"p"},"finalize()")," call."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function prefinalize(uint256[] _batches, uint256 _maxShareRate)\n    view\n    returns (uint256 ethToLock, uint256 sharesToBurn)\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_batches"))," \u2014 finalization batches calculated off-chain using ",(0,i.kt)("inlineCode",{parentName:"li"},"calculateFinalizationBatches()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_maxShareRate"))," \u2014 max share rate (ETH per share) for request finalization (1e27 precision)")),(0,i.kt)("p",null,"Returns"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"ethToLock"))," \u2014 the amount of ether to be sent with ",(0,i.kt)("inlineCode",{parentName:"li"},"finalize()")," method"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"sharesToBurn"))," \u2014 the number of shares to be burnt to match this finalization call")),(0,i.kt)("h2",{id:"protected-methods"},"Protected methods"),(0,i.kt)("h3",{id:"roles"},"Roles"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"FINALIZE_ROLE")," \u2014 role to finalize withdrawal requests in the queue"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"PAUSE_ROLE")," \u2014 role to pause the withdrawal on the protocol"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"RESUME_ROLE")," \u2014 role to resume the withdrawal after being paused"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ORACLE_ROLE")," \u2014 role to provide required oracle-related data as the last report timestamp\nand if the protocol is in the bunker mode"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"MANAGE_TOKEN_URI_ROLE")," \u2014 role to set the parameters for constructing the token URI: the base URI\nor ",(0,i.kt)("inlineCode",{parentName:"li"},"NFTDescriptor")," address")),(0,i.kt)("h3",{id:"finalize"},"finalize()"),(0,i.kt)("p",null,"Finalize requests from the last finalized one up to ",(0,i.kt)("inlineCode",{parentName:"p"},"_lastRequestIdToBeFinalized")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"_maxShareRate"),"\nas a base share rate for ",(0,i.kt)("inlineCode",{parentName:"p"},"stETH")," and passing along some ether as ",(0,i.kt)("inlineCode",{parentName:"p"},"msg.value"),".\nThe amount of ether to send should be precalculated by the ",(0,i.kt)("inlineCode",{parentName:"p"},"prefinalize()")," method."),(0,i.kt)("p",null,"Emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"BatchMetadataUpdate")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"WithdrawalsFinalized")," events."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function finalize(uint256 _lastRequestIdToBeFinalized, uint256 _maxShareRate) payable\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_lastRequestIdToBeFinalized"))," \u2014 the last request id to finalize"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_maxShareRate"))," \u2014 the max share rate (ETH per share) for the request finalization (1e27 precision)")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"withdrawals must not be paused"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must have the ",(0,i.kt)("inlineCode",{parentName:"li"},"FINALIZE_ROLE")," assigned"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_lastRequestIdToBeFinalized")," must be an existing unfinalized request id"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"msg.value")," must be less or equal to the sum of unfinalized ",(0,i.kt)("inlineCode",{parentName:"li"},"stETH")," up to ",(0,i.kt)("inlineCode",{parentName:"li"},"_lastRequestIdToBeFinalized")))),(0,i.kt)("h3",{id:"pausefor"},"pauseFor()"),(0,i.kt)("p",null,"Pause withdrawal requests placement and finalization for particular ",(0,i.kt)("inlineCode",{parentName:"p"},"_duration"),". Claiming finalized requests\nwill still be available."),(0,i.kt)("p",null,"Emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"Paused")," event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function pauseFor(uint256 _duration) onlyRole(PAUSE_ROLE)\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_duration"))," \u2014 pause duration in seconds (use ",(0,i.kt)("inlineCode",{parentName:"li"},"PAUSE_INFINITELY")," for unlimited)")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must have a ",(0,i.kt)("inlineCode",{parentName:"li"},"PAUSE_ROLE")," assigned"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_duration")," must not be zero"),(0,i.kt)("li",{parentName:"ul"},"the contract must not be already paused"))),(0,i.kt)("h3",{id:"pauseuntil"},"pauseUntil()"),(0,i.kt)("p",null,"Pause withdrawal requests placement and finalization until ",(0,i.kt)("inlineCode",{parentName:"p"},"_pauseUntilInclusive")," timestamp.\nClaiming finalized requests will still be available."),(0,i.kt)("p",null,"Emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"Paused")," event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function pauseUntil(uint256 _pauseUntilInclusive) onlyRole(PAUSE_ROLE)\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_pauseUntilInclusive"))," \u2014 the ",(0,i.kt)("inlineCode",{parentName:"li"},"block.timestamp")," to pause until (inclusive)")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must have a ",(0,i.kt)("inlineCode",{parentName:"li"},"PAUSE_ROLE")," assigned"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_pauseUntilInclusive")," must not be in the past"),(0,i.kt)("li",{parentName:"ul"},"the contract must not be already paused"))),(0,i.kt)("h3",{id:"resume"},"resume()"),(0,i.kt)("p",null,"Resumes withdrawal requests placement and finalization.\nThe contract is deployed in a paused state and should be resumed explicitly."),(0,i.kt)("p",null,"Emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"Resumed")," event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function resume()\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must have a ",(0,i.kt)("inlineCode",{parentName:"li"},"RESUME_ROLE")," assigned"),(0,i.kt)("li",{parentName:"ul"},"the contract must not be already resumed"))),(0,i.kt)("h3",{id:"onoraclereport"},"onOracleReport()"),(0,i.kt)("p",null,"Updates bunker mode state and last report timestamp."),(0,i.kt)("p",null,"Emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"BunkerModeEnabled")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},"BunkerModeDisabled")," event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function onOracleReport(\n    bool _isBunkerModeNow,\n    uint256 _bunkerStartTimestamp,\n    uint256 _currentReportTimestamp\n)\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_isBunkerModeNow"))," \u2014 is bunker mode reported by the oracle"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_bunkerStartTimestamp"))," \u2014 timestamp of the bunker mode activation"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_currentReportTimestamp"))," \u2014 timestamp of the current report ref slot")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Requirements:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," must have an ",(0,i.kt)("inlineCode",{parentName:"li"},"ORACLE_ROLE")," assigned"),(0,i.kt)("li",{parentName:"ul"},"all timestamps must be in the past"))),(0,i.kt)("h3",{id:"setbaseuri"},"setBaseUri()"),(0,i.kt)("p",null,"Sets the Base URI for computing token URI."),(0,i.kt)("p",null,"If the ",(0,i.kt)("inlineCode",{parentName:"p"},"NFTDescriptor")," address isn't set, the ",(0,i.kt)("inlineCode",{parentName:"p"},"baseURI")," would be used for generating the ",(0,i.kt)("inlineCode",{parentName:"p"},"ERC-721")," token URI.\nOtherwise, the ",(0,i.kt)("inlineCode",{parentName:"p"},"NFTDescriptor")," address would be used as a first-priority method."),(0,i.kt)("p",null,"Emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseURISet")," event"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function setBaseURI(string _baseURI) external onlyRole(MANAGE_TOKEN_URI_ROLE)\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_baseURI"))," \u2014 the base URI to derive the token URI from. Should not end on ",(0,i.kt)("inlineCode",{parentName:"li"},"/"))),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Reverts if ",(0,i.kt)("inlineCode",{parentName:"p"},"msg.sender")," has no ",(0,i.kt)("inlineCode",{parentName:"p"},"MANAGE_TOKEN_URI_ROLE")," assigned.")),(0,i.kt)("h3",{id:"setnftdescriptoraddress"},"setNFTDescriptorAddress()"),(0,i.kt)("p",null,"Sets the address of the ",(0,i.kt)("inlineCode",{parentName:"p"},"NFTDescriptor")," contract responsible for token URI generation."),(0,i.kt)("p",null,"If the ",(0,i.kt)("inlineCode",{parentName:"p"},"NFTDescriptor")," address isn't set, the ",(0,i.kt)("inlineCode",{parentName:"p"},"baseURI")," would be used for generating the ",(0,i.kt)("inlineCode",{parentName:"p"},"ERC-721")," token URI.\nOtherwise, the ",(0,i.kt)("inlineCode",{parentName:"p"},"NFTDescriptor")," address would be used as a first-priority method."),(0,i.kt)("p",null,"Emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"NftDescriptorAddressSet")," event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"function setNFTDescriptorAddress(address _nftDescriptorAddress) onlyRole(MANAGE_TOKEN_URI_ROLE)\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"_nftDescriptorAddress"))," \u2014 is the address of ",(0,i.kt)("inlineCode",{parentName:"li"},"NFTDescriptor")," contract,\nwhich must support the ",(0,i.kt)("inlineCode",{parentName:"li"},"INFTDescriptor")," interface:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol"},"interface INFTDescriptor {\n  function constructTokenURI(uint256 _requestId) external view returns (string memory)\n}\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Reverts if ",(0,i.kt)("inlineCode",{parentName:"p"},"msg.sender")," has no ",(0,i.kt)("inlineCode",{parentName:"p"},"MANAGE_TOKEN_URI_ROLE")," assigned.")))}m.isMDXComponent=!0}}]);